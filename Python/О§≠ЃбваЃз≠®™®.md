#### Хорошие однострочники
- `a, b, = b, a` - обмен значений переменных (можно любое кол. переменных)
- `a, b, c = распаковка` - можно ввести данные и программа сама их распакует в переменные
**пример:**
```python
a, b, c = input('Введите три символа:')
print(f'{a = } {b = } {c = }')
```
**результат:**
```python
Введите три символа: \*123\*
a = '1' b = '2' c = 3 
```
\# количество вводимых (распаковываемых) элементов должно соответствовать количеству переменных. Эту проблему (количество элементов больше переменных) можно обойти с помощью подстановки знака '\*' 
`(a, b, \*c = str, tuple, set )`. Все лишние элементы упаковываются в список. Символ '\*' это перебор значений замена цикла for
**пример:**
```python
data = [1, 2, 3, 4]
for item in data:
	print(item)
```
равнозначно
```python
data = [1, 2, 3, 4]
print(\*data)
```

- `a = b = c = 0` - присваивание сразу нескольким переменным 
- `a, b, c = 1, 2, 3` - присвоение сразу нескольким переменным разных значений
- `t = 1, 2, 3` - присвоение одной переменной несколько элементов, образует кортеж из этих элементов и присвоит переменой

- `a == b == c или a < b < c` - множественное сравнение

- `['выражени/элемнт' for 'элемент' in 'последовательность' if 'условие'] = list_comprehension` - генератор списков, принимает на вход выражение (функцию), последовательность и если необходимо проверочное условие и формирует список, присваивая его переменной. 

- `('выражени/элемнт' for 'элемент' in 'последовательность' if 'условие')` - генераторное выражение, отличается от списка тем, что не хранит все значения, а выдает по одному.

- `{'выражени/элемнт' for 'элемент' in 'последовательность' if 'условие'} = set_comprehension` - генератор множеств, также как и список генерирует множество и присваивает его переменной

- `{'key: value' for 'элемент' in 'последовательность' if 'условие'} = dict_comprehension` - генератор словарей также как и список генерирует словарь и присваивает его переменной

- функция генератор (возвращает одно значение функции по необходимости)
```python
def func(\*args, \*\*kwargs):
	. . .
	yield . . .
```
как только функция дойдет до слова yield, она останавливается. В этом момент запоминаются все переменные в функции и последнее значение которое выдала функция. При дальнейшем вызове функции, она начнет работать с того места где остановилась.