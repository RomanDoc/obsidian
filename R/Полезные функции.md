- `gsub('заменяемое значение', 'на что меняем', 'где меняем')` - функция замены значений
**примеры:**
```R
# преобразование строковых данных в числовые
# преобразовать можно если в значение стоит точка а не запятая
nums_chr <- c('2,3', '8,2', '7,4', '9', '3,5')
cat(nums_chr)
class(nums_chr)
nums_chr <- gsub(',', '.', nums_chr) # замена запятой на точку
cat(nums_chr)
class(nums_chr)
nums_num <- as.numeric(nums_chr)
cat(nums_num)
class(nums_num)
```
**результат:**
```R
2,3 8,2 7,4 9 3,5
[1] "character"
2.3 8.2 7.4 9 3.5
[1] "character"
2.3 8.2 7.4 9 3.5
[1] "numeric"
```
- `strsplit(строка, 'символ разделения')` - разбивает строку на части по символу разделения и возвращает список.
**примеры:**
```R
my_str <- '2.3, 4, 5.6, 7.3'
print(my_str)
my_list <- strsplit(my_str, ',')
print(my_list)
```
**результат:**
```R
[1] "2.3, 4, 5.6, 7.3"
[[1]]
[1] "2.3"  " 4"   " 5.6" " 7.3"
```
- `unlist(список)` - преобразовывает список в вектор
**примеры:**
```R
my_vector <- unlist(my_list)
print(my_vector)
```
**результат:**
```R
[1] "2.3"  " 4"   " 5.6" " 7.3"
```

- `paste()` - функция для склеивания переменные и векторы разных типов в строки
**примеры:**
```R
# склеиваим три пременных в одну строку
paste("new", "user", 1)
# тоже стмое но с разделителем '-'
paste("new", "user", 1, sep = "-")
# создадим последовательность
n <- 120
nums <- 1:n
head(nums) # показывает несколько первых элементов
# склеим строку с последовательностью
user_tab <- paste('user', nums, sep = '_')
head(user_tab)
```
**результат:**
```R
[1] "new user 1"

[1] "new-user-1"

[1] 1 2 3 4 5 6

[1] "user_1" "user_2" "user_3" "user_4" "user_5" "user_6"
```
если  дописать дополнительный параметр `collapse =` позволяет преобразовать вектор в строку (`paste(переменные, collapse = ' ')`).

- `rep(переменноя, количество повторений)` - функция создает вектор с повторяющимися значениями
**примеры:**
```R
# повторение одного значения
rep(0, 4)
# повторения вектора значений
rep(c("нет ответа", "другое"), 3)
# повторение каждого значения вектора
rep(c("нет ответа", "другое"), each = 3)
```
**результат:**
```R
[1] 0 0 0 0

[1] "нет ответа" "другое" "нет ответа" "другое" "нет ответа" "другое"

[1] "нет ответа" "нет ответа" "нет ответа" "другое" "другое" "другое"
```

- `grepl(символ, переменная)` - функция проверяет есть ли такой символ в переменной
**примеры:**
```R
a <- 'Roman'
# проверяем входит ли символ 'k' в строку 'Rpman'
grepl('k', a)
# проверяем входит ли символ 'a' в строку 'Rpman'
```
**результат:**
```R
[1] FALSE
```

- `apply(матрица, 1 или 2, функция)` - функция применяющая какую-нибудь функцию к матрице, 1 - по строкам, 2 - по столбцам.
**примеры:**
```R
m <- matrix(1:9, ncol = 3, nrow = 3)
apply(m, 1, sum)
# сумма значений по строкам
apply(m, 2, sum)
# сумма значений по столбцам
```
**результат:**
```R
[1] 12 15 18

[1]  6 15 24
```

- `lapply(), sapply()` - также как функция `apply` применяет какую-то функцию только к спискам или векторам. Соответственно функция `lapply` возвращает список, а функция `sapply` возвращает вектор.
**примеры:**
```R
income <- list(c(30, 55, 45), c(40, 25, 30))

lapply(income, max)
sapply(income, max)
```
**результат:**
```R
[[1]]
[1] 55

[[2]]
[1] 40

[1] 55 40
```

- `colnames()` - создает вектор названий колонок.

- `dim()` - показывает размерность таблицы

- `ifelse(условие(функция), значение если TRUE, значение если FALSE)` - проверяет значение и возвращает результат в зависимости от того прошло условие или нет

- `nchar()` - определение длины строки

- `which(данные == условия)` - функция возвращает позицию элементов согласно условию

- `is.na(датафрейм)` - выводит матрицу датафрейма, где TRUE - есть пропуск и FALSE - нет пропуска (`sum(is.na(датафрейм))` - выводит общее количество пропусков)

- `complete.cases(датафрейм)` - выводит матрицу датафрейма, где FALSE - есть пропуск и TRUE - нет пропуска (`sum(!complete.cases(датафрайм))` - выводит общее количество строк где есть пропуски)

- `table(данные)` - выводит количество частот значений в данных

- `separate(данные, название столбцов)` - разбивает указанный столбец на данные, разделителем по умолчанию являются любые знаки препинания и присваивает их новым столбцам, названия указаны в функции

- `sample(данные, кол-во случайных значений)` - создает вектор с заданным кол-вом случайных значений из набора данных.

- `distinct(данные)` - выбор уникальных значений

- `list.file(путь до гатолога)` - возвращает список имен файлов в указанном каталоге

- `aggregate()` - функция аггрегации данных